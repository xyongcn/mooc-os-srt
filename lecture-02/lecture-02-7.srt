0
00:00:00,000 --> 00:00:06,480


1
00:00:06,520 --> 00:00:08,000
接下来给大家demo一下

2
00:00:08,040 --> 00:00:11,200
有关lab0的一些实验环节

3
00:00:11,240 --> 00:00:13,720
特别是实验环节的一些建立的过程

4
00:00:13,760 --> 00:00:14,680
可以看到我们现在

5
00:00:14,720 --> 00:00:18,720
已经打开virtualBox虚拟的这个模拟器

6
00:00:18,760 --> 00:00:19,920
那在virtualBox里面呢

7
00:00:19,960 --> 00:00:22,600
我们其实已经建立好了一个叫moocos.lab

8
00:00:22,640 --> 00:00:24,480
这么一个虚拟的硬盘

9
00:00:24,520 --> 00:00:26,280
这里面可以看出这个配置怎么回事呢

10
00:00:26,320 --> 00:00:29,800
我们配置这个Ubuntu64一个环境

11
00:00:29,840 --> 00:00:31,640
有4G的内存

12
00:00:31,680 --> 00:00:33,800
然后这是一些显卡等等

13
00:00:33,840 --> 00:00:36,320
这个就是一些常规的设置

14
00:00:36,360 --> 00:00:37,600
比较重要是这个硬盘

15
00:00:37,640 --> 00:00:38,680
我们这个硬盘已经建立好了

16
00:00:38,720 --> 00:00:42,680
叫mooc-os.vdi

17
00:00:42,720 --> 00:00:45,120
给它虚拟了8G这个内存空间

18
00:00:45,160 --> 00:00:46,000
还有网卡

19
00:00:46,040 --> 00:00:53,360
我们可以看看点击 启动

20
00:00:53,400 --> 00:00:56,520
那它就开始模拟一台计算机启动

21
00:00:56,560 --> 00:00:57,360
在这个启动过程中呢

22
00:00:57,400 --> 00:01:02,360
可以看到Ubuntu的一个启动过程

23
00:01:02,400 --> 00:01:03,520
我们接下来的操作呢

24
00:01:03,560 --> 00:01:04,160
基本上就是在

25
00:01:04,200 --> 00:01:12,280
这个Ubuntu环境中来完成的

26
00:01:12,320 --> 00:01:14,840
那可以看出来这里面

27
00:01:14,880 --> 00:01:18,120
这是一个linux Ubuntu的一个环境

28
00:01:18,160 --> 00:01:21,320
那我们用14.04这么一个版本

29
00:01:21,360 --> 00:01:28,920
我们首先进入全屏模式

30
00:01:28,960 --> 00:01:30,320
好 你可以看到现在进入全屏模式

31
00:01:30,360 --> 00:01:33,120
其实就和我们在一般的linux操作

32
00:01:33,160 --> 00:01:34,640
是差不多的了

33
00:01:34,680 --> 00:01:40,160
那在这里面呢 我们打开一个shell

34
00:01:40,200 --> 00:01:42,480
那我们的这个实验环境

35
00:01:42,520 --> 00:01:47,120
是放在moocos下面的

36
00:01:47,160 --> 00:01:48,800
那我们可以看到所有的

37
00:01:48,840 --> 00:01:52,760
code放在ucor_lab下面

38
00:01:52,800 --> 00:01:53,880
这里面有两部分

39
00:01:53,920 --> 00:01:55,320
一部分是labcodes

40
00:01:55,360 --> 00:01:57,280
可以看到lab1到lab8

41
00:01:57,320 --> 00:01:59,320
需要去填空的代码放在这儿了

42
00:01:59,360 --> 00:02:05,680
但是呢我们也提供了答案

43
00:02:05,720 --> 00:02:07,360
这是lab1到lab8的答案

44
00:02:07,400 --> 00:02:08,840
如果大家确实做不出来的话

45
00:02:08,880 --> 00:02:10,280
也可以参考相应的答案

46
00:02:10,320 --> 00:02:11,120
以及做出来之后

47
00:02:11,160 --> 00:02:13,200
可以跟这个参考答案做一个对比

48
00:02:13,240 --> 00:02:14,840
这里面呢没有绝对的对错

49
00:02:14,880 --> 00:02:16,320
只是做一个参考而已

50
00:02:16,360 --> 00:02:17,000
那接下来我们可以看到

51
00:02:17,040 --> 00:02:20,240
我们已经用到了ls命令 是吧 显示目录

52
00:02:20,280 --> 00:02:23,720
pwd呢是显示当前目录 还有什么呢

53
00:02:23,760 --> 00:02:28,240
比如说我们再建一个目录

54
00:02:28,280 --> 00:02:32,240
那会看到多了一个test目录

55
00:02:32,280 --> 00:02:35,840
当然我们也可以做比如把前面那个

56
00:02:35,880 --> 00:02:38,120
这么一个文件移到这儿来

57
00:02:38,160 --> 00:02:39,560
移到当前目录下

58
00:02:39,600 --> 00:02:40,560
当前目录下

59
00:02:40,600 --> 00:02:42,760
那可以看到test多了这么一个文件

60
00:02:42,800 --> 00:02:46,720
还有呢 我可以把它删除

61
00:02:46,760 --> 00:02:47,800
这个文件就没有了

62
00:02:47,840 --> 00:02:50,680
这是简单的创建目录显示

63
00:02:50,720 --> 00:02:52,240
然后移动文件

64
00:02:52,280 --> 00:02:53,600
还有创建文件等等

65
00:02:53,640 --> 00:02:55,960
都可以用这个来实现

66
00:02:56,000 --> 00:02:57,320
那这是所谓的通常的

67
00:02:57,360 --> 00:02:59,840
基于这个shell的一些操作命令

68
00:02:59,880 --> 00:03:00,880
当然我们也可以

69
00:03:00,920 --> 00:03:02,440
通过一种图形界面方式

70
00:03:02,480 --> 00:03:03,560
比如打开这个

71
00:03:03,600 --> 00:03:05,520
这是一个类似于资源管理器

72
00:03:05,560 --> 00:03:08,520
你也可以在这里面打开moocos

73
00:03:08,560 --> 00:03:11,400
我们刚才看到这个mooclab

74
00:03:11,440 --> 00:03:13,800
然后看到test

75
00:03:13,840 --> 00:03:17,000
那你可以采取这种图形界面方式改名

76
00:03:17,040 --> 00:03:19,040
test2这种改名

77
00:03:19,080 --> 00:03:23,520
删除呢 move to trash移到垃圾箱里面去

78
00:03:23,560 --> 00:03:25,400
看这儿可以看到

79
00:03:25,440 --> 00:03:26,800
还可以恢复它

80
00:03:26,840 --> 00:03:28,120
这儿

81
00:03:28,160 --> 00:03:34,960
restore那在这儿我可以把它彻底的删掉

82
00:03:35,000 --> 00:03:38,480
shift delete 那就可以把它彻底删掉了

83
00:03:38,520 --> 00:03:41,640
那这也是通过这种图形界面来使用

84
00:03:41,680 --> 00:03:44,040
很多同学可能对这个也比较熟悉

85
00:03:44,080 --> 00:03:44,600
这是一些

86
00:03:44,640 --> 00:03:46,960
常见的一些对文件的一些访问

87
00:03:47,000 --> 00:03:47,800
还有一个就是什么呢

88
00:03:47,840 --> 00:03:49,920
我们开发环境中也有一些命令

89
00:03:49,960 --> 00:03:52,840
比如说gcc你可以看到

90
00:03:52,880 --> 00:03:54,400
我们这里面有是有gcc的代码

91
00:03:54,440 --> 00:03:57,200
还有gdb 退出quit

92
00:03:57,240 --> 00:04:00,200
退出这个gdb的代码 make等等

93
00:04:00,240 --> 00:04:01,200
另一方面我们还可以看到

94
00:04:01,240 --> 00:04:02,720
我们希望有一个很方便

95
00:04:02,760 --> 00:04:05,560
来完成我们实验的一个环境

96
00:04:05,600 --> 00:04:06,120
当然我们完全可以

97
00:04:06,160 --> 00:04:07,960
用这种字符方式来完成

98
00:04:08,000 --> 00:04:09,680
就基于命令行的方式

99
00:04:09,720 --> 00:04:10,480
举个例子比如说

100
00:04:10,520 --> 00:04:14,200
我们现在到lab_answer目录下

101
00:04:14,240 --> 00:04:15,920
然后看一下lab1

102
00:04:15,960 --> 00:04:17,280
比如make clean一下

103
00:04:17,320 --> 00:04:19,080
make clean这时候因为有makefile

104
00:04:19,120 --> 00:04:20,760
所以make clean找make file

105
00:04:20,800 --> 00:04:22,680
然后来执行clean这个命令

106
00:04:22,720 --> 00:04:24,360
会把相应的这些 

107
00:04:24,400 --> 00:04:26,240
生成的这些执行文件给删除掉

108
00:04:26,280 --> 00:04:28,920
那我们make 回车

109
00:04:28,960 --> 00:04:30,480
那你看到它整个编译过程

110
00:04:30,520 --> 00:04:32,040
会把虚拟磁盘镜像给建立好

111
00:04:32,080 --> 00:04:33,360
这里面包含了kernel

112
00:04:33,400 --> 00:04:35,600
在bin目录下有kernel这么一个文件

113
00:04:35,640 --> 00:04:36,800
如果用file看一下的话

114
00:04:36,840 --> 00:04:37,800
这个文件可以看到

115
00:04:37,840 --> 00:04:39,480
它是一个可执行的一个文件

116
00:04:39,520 --> 00:04:41,120
它会把我们bootloader给加进去

117
00:04:41,160 --> 00:04:42,480
那bootloader放哪呢

118
00:04:42,520 --> 00:04:48,640
它这个Bin目录下还有一个什么文件呢

119
00:04:48,680 --> 00:04:49,800
ucore.img这实际上就是

120
00:04:49,840 --> 00:04:53,960
我们用到bootloader它生成一个磁盘镜像

121
00:04:54,000 --> 00:04:55,520
这个磁盘镜像包含了bootloader

122
00:04:55,560 --> 00:04:58,600
以及ucore的这个kernel

123
00:04:58,640 --> 00:05:02,680
我们怎么来运行它呢

124
00:05:02,720 --> 00:05:06,040
make qemu 那么它会调qemu来执行它

125
00:05:06,080 --> 00:05:07,400
这里面可以看到这是lab1

126
00:05:07,440 --> 00:05:10,080
其实lab1的代码 我们只是来做测试一下

127
00:05:10,120 --> 00:05:12,360
可以看出来它可以跑起来了

128
00:05:12,400 --> 00:05:15,040
而且这个时钟中断可以正常工作

129
00:05:15,080 --> 00:05:17,920
这是一个qemu它可以通过串口输出

130
00:05:17,960 --> 00:05:19,200
也可以输到屏幕上

131
00:05:19,240 --> 00:05:20,240
这是ctrl c

132
00:05:20,280 --> 00:05:21,400
Ctrl c整个中断了

133
00:05:21,440 --> 00:05:23,320
那么又回到了初始状态

134
00:05:23,360 --> 00:05:24,600
看到我们这里面

135
00:05:24,640 --> 00:05:25,880
当你做完make时候呢

136
00:05:25,920 --> 00:05:27,200
它生成了很多文件

137
00:05:27,240 --> 00:05:29,760
包括obj文件 包括bin文件等等

138
00:05:29,800 --> 00:05:31,520
那我们可以去编辑它

139
00:05:31,560 --> 00:05:34,040
比如说我们曾经说过有vim

140
00:05:34,080 --> 00:05:36,800
看一下这个Mmake file什么内容

141
00:05:36,840 --> 00:05:38,160
那可以看到这里面

142
00:05:38,200 --> 00:05:40,120
有定义很多的一些变量

143
00:05:40,160 --> 00:05:41,120
当然这些变量都是

144
00:05:41,160 --> 00:05:44,200
符合makefile的语法格式的

145
00:05:44,240 --> 00:05:45,320
大家需要去了解

146
00:05:45,360 --> 00:05:46,960
我们现在退出了vim

147
00:05:47,000 --> 00:05:48,960
当然这些操作都是字符方式

148
00:05:49,000 --> 00:05:51,000
如果大家对字符方式很熟的话

149
00:05:51,040 --> 00:05:52,920
用字符方式足够了

150
00:05:52,960 --> 00:05:54,400
但是也有很多同学

151
00:05:54,440 --> 00:05:56,320
可能不太熟悉这种字符方式

152
00:05:56,360 --> 00:05:58,160
需要跟windows类似的

153
00:05:58,200 --> 00:06:00,400
图形化的一种操作界面

154
00:06:00,440 --> 00:06:01,720
那我们这里面也提供了

155
00:06:01,760 --> 00:06:02,880
比如说我们这里面建立了

156
00:06:02,920 --> 00:06:05,720
这个eclipse-CDT环境

157
00:06:05,760 --> 00:06:07,880
单击一下可以把它打开

158
00:06:07,920 --> 00:06:08,600
稍微等一下 

159
00:06:08,640 --> 00:06:12,760
因为它有一个加载的过程

160
00:06:12,800 --> 00:06:16,040
我们这里面可以看到是一个

161
00:06:16,080 --> 00:06:19,200
比如说我们到一个c++的一个开发环境中

162
00:06:19,240 --> 00:06:21,320
我们可以看到我们把刚才

163
00:06:21,360 --> 00:06:25,360
这个lab1_ans的目录导进来了

164
00:06:25,400 --> 00:06:27,360
可以看到这是一个Project

165
00:06:27,400 --> 00:06:29,120
这是C的一个Project

166
00:06:29,160 --> 00:06:31,320
其实是lab1的工程

167
00:06:31,360 --> 00:06:33,240
这里面包含了我们所有代码

168
00:06:33,280 --> 00:06:34,840
比如说这里面是boot代码

169
00:06:34,880 --> 00:06:38,640
你要想看这个代码点击一下 双击一下

170
00:06:38,680 --> 00:06:40,880
那么就可以看它的源代码

171
00:06:40,920 --> 00:06:42,760
就可以去分析它 这里面有c

172
00:06:42,800 --> 00:06:45,760
有足够的注释 这是bootmain.c

173
00:06:45,800 --> 00:06:47,200
这是bootloader主体函数

174
00:06:47,240 --> 00:06:48,320
它负责加载

175
00:06:48,360 --> 00:06:49,480
我们可以看到这里面

176
00:06:49,520 --> 00:06:52,480
比如这个readseg只要点一下它

177
00:06:52,520 --> 00:06:55,440
它大致的一个位置可以发现出来

178
00:06:55,480 --> 00:06:59,160
如果敲一下F3 那甚至可以到这个函数

179
00:06:59,200 --> 00:07:00,880
可以跳到这个函数里面来

180
00:07:00,920 --> 00:07:05,320
再敲一下F3 比如到了readsect

181
00:07:05,360 --> 00:07:06,160
那可以到这儿来

182
00:07:06,200 --> 00:07:09,440
它可以跨文件来查找不同函数这种引用

183
00:07:09,480 --> 00:07:12,520
通过它很好的可以来分析源代码

184
00:07:12,560 --> 00:07:13,880
那我们怎么来编译它呢

185
00:07:13,920 --> 00:07:15,600
这在编辑环境中

186
00:07:15,640 --> 00:07:18,120
我们编译它其实在这儿也是一样的

187
00:07:18,160 --> 00:07:20,520
你可以把它这里面有一个build

188
00:07:20,560 --> 00:07:22,240
build Project

189
00:07:22,280 --> 00:07:23,640
因为刚才已经编译过了

190
00:07:23,680 --> 00:07:24,960
现在啥也不用做了

191
00:07:25,000 --> 00:07:26,200
它已经编译好了

192
00:07:26,240 --> 00:07:27,320
如果把它clean掉的话

193
00:07:27,360 --> 00:07:33,680
比如说我们把这个shell打开 make clean

194
00:07:33,720 --> 00:07:36,160
再看它这个obj目录和刚才

195
00:07:36,200 --> 00:07:37,640
看到的bin目录已经消失了

196
00:07:37,680 --> 00:07:38,400
已经被删除了

197
00:07:38,440 --> 00:07:41,600
用rm-r是递归删除的意思

198
00:07:41,640 --> 00:07:42,600
就把这两个目录下的

199
00:07:42,640 --> 00:07:44,280
所有文件都删除了

200
00:07:44,320 --> 00:07:46,200
这个时候我们来切换到

201
00:07:46,240 --> 00:07:49,440
就alt tab切换到这个eclipse环境中来

202
00:07:49,480 --> 00:07:53,680
那我们可以再编译一次

203
00:07:53,720 --> 00:07:56,040
你可以看到刚才的重复这个过程

204
00:07:56,080 --> 00:07:59,360
在命令行在这里面也重现了 那编好了

205
00:07:59,400 --> 00:08:01,840
编好了我们怎么运行它呢

206
00:08:01,880 --> 00:08:03,880
我们特别是希望能够debug是吧

207
00:08:03,920 --> 00:08:07,320
运行已经看到make qemu那debug怎么办

208
00:08:07,360 --> 00:08:10,360
debug的话相对来说需要做一些配置

209
00:08:10,400 --> 00:08:11,760
在这里面 我们可以看着

210
00:08:11,800 --> 00:08:12,560
对于这个Project

211
00:08:12,600 --> 00:08:14,720
我们要有一个debug configure

212
00:08:14,760 --> 00:08:15,560
假定我们已经装了

213
00:08:15,600 --> 00:08:19,520
这个Zylin Embedded debug

214
00:08:19,560 --> 00:08:23,000
那大家可能好奇 这个plug in在哪装呢

215
00:08:23,040 --> 00:08:31,000
其实我们先把这个先关掉可以看一看

216
00:08:31,040 --> 00:08:35,560
在install new software这里面呢

217
00:08:35,600 --> 00:08:38,480
你可以看到我们当时装这个地址在这儿

218
00:08:38,520 --> 00:08:39,280
这么一个地址

219
00:08:39,320 --> 00:08:40,120
把它敲进去之后呢

220
00:08:40,160 --> 00:08:43,080
就可以查找它的那个plug in那个主键

221
00:08:43,120 --> 00:08:44,480
那么可以看到

222
00:08:44,520 --> 00:08:46,120
另一方面其实你也可以看着

223
00:08:46,160 --> 00:08:50,120
这里面已经安装的主键

224
00:08:50,160 --> 00:08:52,040
在这儿 installation Detalls

225
00:08:52,080 --> 00:08:55,040
可以看出来装好了这个软件

226
00:08:55,080 --> 00:08:56,720
那么同学可以先把这个软件装好

227
00:08:56,760 --> 00:08:59,160
就可以用来便于我们做调试

228
00:08:59,200 --> 00:09:00,560
我们再回头来看看这个配置

229
00:09:00,600 --> 00:09:01,800
有了这个之后呢

230
00:09:01,840 --> 00:09:04,120
我们在这个debug configuration里面呢

231
00:09:04,160 --> 00:09:06,400
会有一个lab1的一个配置

232
00:09:06,440 --> 00:09:07,360
这个名字随便敲

233
00:09:07,400 --> 00:09:09,920
我们这里面叫lab1 ans Default

234
00:09:09,960 --> 00:09:12,360
那Projectlab也是一个optional

235
00:09:12,400 --> 00:09:14,160
这是随便填的

236
00:09:14,200 --> 00:09:15,800
debugger这很重要

237
00:09:15,840 --> 00:09:17,080
你要选择哪种debugger

238
00:09:17,120 --> 00:09:19,760
我们这边就用了EmbeddedGDB

239
00:09:19,800 --> 00:09:23,720
然后stop on startup at bootmain

240
00:09:23,760 --> 00:09:26,360
我们想停在刚才说的bootloader

241
00:09:26,400 --> 00:09:27,600
这个函数里面

242
00:09:27,640 --> 00:09:28,800
这里面写个bootmain

243
00:09:28,840 --> 00:09:29,920
或者把它关掉也行

244
00:09:29,960 --> 00:09:32,440
因为我们在后面Commands里面

245
00:09:32,480 --> 00:09:35,600
也会在这儿有一个gdb命名break

246
00:09:35,640 --> 00:09:38,160
好 bootmain 这是设置debug

247
00:09:38,200 --> 00:09:41,320
到底用哪个debugger呢

248
00:09:41,360 --> 00:09:42,880
所以用的gdb的debugger

249
00:09:42,920 --> 00:09:45,720
这是一个命令行方式的一个调试工具

250
00:09:45,760 --> 00:09:47,400
我们这里面只是把它加个壳

251
00:09:47,440 --> 00:09:50,400
可以更方便在eclipseide环境中

252
00:09:50,440 --> 00:09:52,880
来调试应用程序

253
00:09:52,920 --> 00:09:55,200
其它这些设置保持不变

254
00:09:55,240 --> 00:09:57,400
这里面commands相当于是说

255
00:09:57,440 --> 00:09:59,760
当如果我们要启动这个调试的时候

256
00:09:59,800 --> 00:10:01,200
需要做的一些工作

257
00:10:01,240 --> 00:10:02,320
这里面工作包括

258
00:10:02,360 --> 00:10:05,080
怎么来跟qemu建立一个连接

259
00:10:05,120 --> 00:10:09,000
从而可以控制qemu来调试我们的lab1

260
00:10:09,040 --> 00:10:11,520
这里面有一些命令你大致能理解一些

261
00:10:11,560 --> 00:10:13,920
这是用来完成对qemu的连接

262
00:10:13,960 --> 00:10:15,840
这个呢第二行是干什么的呢

263
00:10:15,880 --> 00:10:17,920
你要调bootloader的话

264
00:10:17,960 --> 00:10:19,960
那我们前面已经看到的

265
00:10:20,000 --> 00:10:22,040
在boot目录下的是一个程序

266
00:10:22,080 --> 00:10:23,640
是bootloader

267
00:10:23,680 --> 00:10:25,280
在kern目录下是另一个程序

268
00:10:25,320 --> 00:10:26,440
是我们ucore

269
00:10:26,480 --> 00:10:29,280
bootloader会加载ucore

270
00:10:29,320 --> 00:10:30,720
那所以说在这里面呢

271
00:10:30,760 --> 00:10:31,840
我们首先要把bootloader

272
00:10:31,880 --> 00:10:34,120
这个符号加载进来

273
00:10:34,160 --> 00:10:34,720
用这个命名

274
00:10:34,760 --> 00:10:37,000
这是一个在obj目录下

275
00:10:37,040 --> 00:10:39,440
有个bootblock.o

276
00:10:39,480 --> 00:10:40,560
这个文件实际上

277
00:10:40,600 --> 00:10:43,240
是bootloader的主体执行程序

278
00:10:43,280 --> 00:10:44,520
它里面包含了符号信息

279
00:10:44,560 --> 00:10:48,360
比如这个函数它的位置有break bootmain

280
00:10:48,400 --> 00:10:50,040
等于是说在bootmain所对应的

281
00:10:50,080 --> 00:10:51,000
那个虚拟地址里面呢

282
00:10:51,040 --> 00:10:51,920
设置一个断点

283
00:10:51,960 --> 00:10:53,080
这是gdb初始化命名

284
00:10:53,120 --> 00:10:55,160
所以continue是让它执行

285
00:10:55,200 --> 00:10:55,960
在这个执行之前

286
00:10:56,000 --> 00:10:58,840
首先要把我们说的这个qemu启起来

287
00:10:58,880 --> 00:11:01,000
那么这里面我们也配好了一个

288
00:11:01,040 --> 00:11:02,800
外部工具来启qemu

289
00:11:02,840 --> 00:11:04,200
比如说在这里面你可以看到

290
00:11:04,240 --> 00:11:05,760
我们准备了一个什么工具呢

291
00:11:05,800 --> 00:11:07,920
lab1ans有一个运行一个make命令

292
00:11:07,960 --> 00:11:09,440
make命令会根据makefile里面

293
00:11:09,480 --> 00:11:11,760
查找一个gdb一个选项

294
00:11:11,800 --> 00:11:14,560
然后make gdb就可以把qemu提起来

295
00:11:14,600 --> 00:11:15,600
我们可以看一看

296
00:11:15,640 --> 00:11:19,400
假设我们在这里面run一下

297
00:11:19,440 --> 00:11:23,680
这所有操作都在这个集成开发环境里面

298
00:11:23,720 --> 00:11:29,720
选择外部工具 你可以看着qemu在等待

299
00:11:29,760 --> 00:11:31,840
等待跟gdb建立一个联系

300
00:11:31,880 --> 00:11:34,400
处于一个刚开始运行的状态

301
00:11:34,440 --> 00:11:36,600
然后如果我们现在之后

302
00:11:36,640 --> 00:11:39,480
再运行一下debug这个的话

303
00:11:39,520 --> 00:11:44,520
那我们就可以看到 就会有些问题

304
00:11:44,560 --> 00:11:45,120
我们这里面

305
00:11:45,160 --> 00:11:47,560
可以看到qemu先把它设在最前端

306
00:11:47,600 --> 00:11:49,840
这样可以时刻观察它的变化

307
00:11:49,880 --> 00:11:51,440
它问你是否要进入

308
00:11:51,480 --> 00:11:54,480
一个debug一个view的一个状态

309
00:11:54,520 --> 00:11:55,600
我们认为yes

310
00:11:55,640 --> 00:11:57,800
因为我们需要在debugview下面

311
00:11:57,840 --> 00:12:00,960
更好来调试和分析我们程序

312
00:12:01,000 --> 00:12:03,960
你看到现在这个已经断在了debug

313
00:12:04,000 --> 00:12:06,360
你看debug current指令指针

314
00:12:06,400 --> 00:12:07,280
我们接下来干什么呢

315
00:12:07,320 --> 00:12:09,160
很简单就像我们通常

316
00:12:09,200 --> 00:12:11,080
调应用程序一样 step Over

317
00:12:11,120 --> 00:12:13,160
就是跳过这个函数去执行它

318
00:12:13,200 --> 00:12:14,000
它为什么会跳几下

319
00:12:14,040 --> 00:12:15,520
是由于它这个做了优化

320
00:12:15,560 --> 00:12:17,200
使得这个地址和源码之间的

321
00:12:17,240 --> 00:12:19,560
对应关系并不是完全对应好的

322
00:12:19,600 --> 00:12:21,280
如果你不做任何优化就可以对上

323
00:12:21,320 --> 00:12:22,840
这里面我们可能好奇

324
00:12:22,880 --> 00:12:26,400
这个ph到底是多少值 它现在是零

325
00:12:26,440 --> 00:12:27,840
因为一开始还没有做赋值

326
00:12:27,880 --> 00:12:29,520
做完这个赋值之后就不应该是零了

327
00:12:29,560 --> 00:12:32,440
可以看到什么呢

328
00:12:32,480 --> 00:12:35,800
再看ph 它已经赋了一个值

329
00:12:35,840 --> 00:12:36,880
可以看出来这种方式

330
00:12:36,920 --> 00:12:38,960
就可以把这个程序的执行过程

331
00:12:39,000 --> 00:12:40,480
很容易的分析清楚

332
00:12:40,520 --> 00:12:41,560
在这里面需要注意 

333
00:12:41,600 --> 00:12:44,240
我们如果要调试ucore

334
00:12:44,280 --> 00:12:46,200
为此我们需要把ucore

335
00:12:46,240 --> 00:12:47,960
那个符号信息加载进来

336
00:12:48,000 --> 00:12:51,840
在这里面我们会到Console这个里面呢

337
00:12:51,880 --> 00:12:53,800
会把这个加进来 在哪加呢

338
00:12:53,840 --> 00:12:58,400
会把这个叫做file bin kernel加进来

339
00:12:58,440 --> 00:13:00,360
reading symbols读进来之后呢

340
00:13:00,400 --> 00:13:02,200
这里面有一个起止函数

341
00:13:02,240 --> 00:13:04,600
这是ucore那个最开始跑的

342
00:13:04,640 --> 00:13:07,040
一个c程序的函数

343
00:13:07,080 --> 00:13:09,400
设置好了 然后这时候

344
00:13:09,440 --> 00:13:15,920
我们如果再让它继续运行

345
00:13:15,960 --> 00:13:17,240
你可以看到

346
00:13:17,280 --> 00:13:21,400
它现在已经跑完了就是bootloader的工作

347
00:13:21,440 --> 00:13:24,520
然后把控制权交给了ucore另外一个程序

348
00:13:24,560 --> 00:13:26,720
同时因为我们刚刚设的断点

349
00:13:26,760 --> 00:13:29,720
我们可以接着继续调试它

350
00:13:29,760 --> 00:13:31,360
这里面有一个字符串 message

351
00:13:31,400 --> 00:13:32,120
message等于多少呢

352
00:13:32,160 --> 00:13:35,160
刚才说的THUCST这一块

353
00:13:35,200 --> 00:13:37,320
那么cprint就会打印出来

354
00:13:37,360 --> 00:13:39,640
那我们再继续执行这个函数

355
00:13:39,680 --> 00:13:41,560
可以看到它已经进去了

356
00:13:41,600 --> 00:13:42,920
字符串已经打印出来了

357
00:13:42,960 --> 00:13:46,120
在这边你看着了有这个字符串的显示

358
00:13:46,160 --> 00:13:48,480
如果我们想进入这里面看它的细节

359
00:13:48,520 --> 00:13:52,480
step in 那你就可以看着

360
00:13:52,520 --> 00:13:54,760
它怎么一步步完成这个打印

361
00:13:54,800 --> 00:13:56,000
这是一个简单的调试

362
00:13:56,040 --> 00:13:57,480
当然我们可以看更复杂一点

363
00:13:57,520 --> 00:13:59,440
比如说我们关注的是

364
00:13:59,480 --> 00:14:02,400
刚才那一段c代码对应的汇编代码

365
00:14:02,440 --> 00:14:03,760
就在这边有展示

366
00:14:03,800 --> 00:14:05,240
我还可以看到特定里

367
00:14:05,280 --> 00:14:06,800
关注的一些变量的一些情况

368
00:14:06,840 --> 00:14:07,960
比如说这个等于多少

369
00:14:08,000 --> 00:14:09,880
这里面其实它等于这些已经列出来

370
00:14:09,920 --> 00:14:13,160
etext等于这么一个值 在这里面有展示

371
00:14:13,200 --> 00:14:14,240
这是大致的一个

372
00:14:14,280 --> 00:14:18,320
在这个eclipse环境下来调试这么一个过程

373
00:14:18,360 --> 00:14:21,840
那我们现在要继续运行的话

374
00:14:21,880 --> 00:14:23,160
那它这个跟刚才

375
00:14:23,200 --> 00:14:29,440
我们在用make qemu这种方式是一样的

376
00:14:29,480 --> 00:14:31,680
比如说举个例子

377
00:14:31,720 --> 00:14:34,520
可以看到一个是在eclipse环境下

378
00:14:34,560 --> 00:14:36,080
调试的这一个qemu

379
00:14:36,120 --> 00:14:38,800
第二个呢是直接执行的一个qemu

380
00:14:38,840 --> 00:14:41,640
这两者呢都可以看出来是差不多一个效果

381
00:14:41,680 --> 00:14:44,600
但是这里面有一些不同之处

382
00:14:44,640 --> 00:14:47,080
我们可以对它进行打断来执行

383
00:14:47,120 --> 00:14:49,840
这是它实际上在这儿 这个已经停止了

384
00:14:49,880 --> 00:14:56,320
但另一个qemu还在继续执行

385
00:14:56,360 --> 00:14:57,520
看这个qemu还在执行

386
00:14:57,560 --> 00:15:01,400
那我大致就把这个通过eclipse来调试呢

387
00:15:01,440 --> 00:15:02,880
给大家做了简单的介绍

388
00:15:02,920 --> 00:15:04,200
当然eclipse功能很强大

389
00:15:04,240 --> 00:15:06,560
大家还可以在使用过程中

390
00:15:06,600 --> 00:15:08,240
再进一步去了解和熟悉

391
00:15:08,280 --> 00:15:09,160
它不仅仅是调试

392
00:15:09,200 --> 00:15:11,720
它还可以用来做分析开发等等

393
00:15:11,760 --> 00:15:13,120
这是很好的开发环境

394
00:15:13,160 --> 00:15:13,840
另外一个工具呢

395
00:15:13,880 --> 00:15:15,640
给大家做个简单介绍 Understand

396
00:15:15,680 --> 00:15:17,120
其实向老师也给大家

397
00:15:17,160 --> 00:15:18,680
做过一个简单的介绍

398
00:15:18,720 --> 00:15:33,360
new Project

399
00:15:33,400 --> 00:15:35,240
那c代码和汇编码

400
00:15:35,280 --> 00:15:37,560
那它在哪加一个目录 这个目录在哪呢

401
00:15:37,600 --> 00:15:40,440
其实就你可以指定一下

402
00:15:40,480 --> 00:15:44,840
比如说你的机器的刚才的地址

403
00:15:44,880 --> 00:15:46,480
在这儿 ucorelab

404
00:15:46,520 --> 00:15:49,800
ucorelad answer然后是lab1 result

405
00:15:49,840 --> 00:15:51,760
那这里面选择一个choose

406
00:15:51,800 --> 00:15:56,280
然后ok next

407
00:15:56,320 --> 00:16:00,480
它会帮你做分析 建好这个目录

408
00:16:00,520 --> 00:16:02,120
那这可以看到

409
00:16:02,160 --> 00:16:05,000
关于这里面的一些调用的函数

410
00:16:05,040 --> 00:16:06,480
比如说readline 

411
00:16:06,520 --> 00:16:09,560
那我们可以看到它的一个调用关系

412
00:16:09,600 --> 00:16:12,080
readline它调了这么多其它的函数

413
00:16:12,120 --> 00:16:14,920
同时也被kmonitor这个函数调用

414
00:16:14,960 --> 00:16:16,480
这个实际上通过understand

415
00:16:16,520 --> 00:16:18,680
可以更好看到一个它的

416
00:16:18,720 --> 00:16:20,840
一个函数调用关系图

417
00:16:20,880 --> 00:16:21,720
也便于大家对

418
00:16:21,760 --> 00:16:24,600
这个操作系统整体的一个把握

419
00:16:24,640 --> 00:16:26,600
这个工具是用来比较的

420
00:16:26,640 --> 00:16:28,640
比如说举个例子

421
00:16:28,680 --> 00:16:38,760
让我们看看lab1和lab2到底有什么不同

422
00:16:38,800 --> 00:16:39,560
那就可以看出来

423
00:16:39,600 --> 00:16:42,680
它里面展示出来它们之间的不同

424
00:16:42,720 --> 00:16:43,760
比如打开这个文件

425
00:16:43,800 --> 00:16:47,960
那你看lab2就多增加了一些内容

426
00:16:48,000 --> 00:16:49,200
也还有lab1和lab2之间

427
00:16:49,240 --> 00:16:50,280
其它地方的一些不同

428
00:16:50,320 --> 00:16:51,680
也都逐一展示出来了

429
00:16:51,720 --> 00:16:53,840
那可以通过很方便的

430
00:16:53,880 --> 00:16:55,520
一个一个的选择来看出

431
00:16:55,560 --> 00:16:57,600
比较它们之间的一些差异性

432
00:16:57,640 --> 00:16:59,600
这是一个diff的一个图形化的工具

433
00:16:59,640 --> 00:17:00,840
当然还有字符方式diff

434
00:17:00,880 --> 00:17:02,960
这个相对来说比较简单一些

435
00:17:03,000 --> 00:17:04,600
但是呢就是如果分析复杂软件的话

436
00:17:04,640 --> 00:17:06,280
用meld好像比较容易一些

437
00:17:06,320 --> 00:17:10,360
至于apt系列 apt.get来查找安装一些软件

438
00:17:10,400 --> 00:17:11,200
sudo是确保是处于

439
00:17:11,240 --> 00:17:14,200
超级用户的权限才能够安装软件

440
00:17:14,240 --> 00:17:16,360
这属于系统一个工具

441
00:17:16,400 --> 00:17:22,080
那比如刚才cdt空格口令

442
00:17:22,120 --> 00:17:24,240
它已经发现eclipse cdt已经安装了

443
00:17:24,280 --> 00:17:25,960
所以说你不需要再重新安装

444
00:17:26,000 --> 00:17:28,240
那么git呢是用来分析这个版本的

445
00:17:28,280 --> 00:17:30,240
或者是上载版本管理

446
00:17:30,280 --> 00:17:33,480
在这里面git status看当前状态

447
00:17:33,520 --> 00:17:36,280
你现在整个是一个很干净的一个环境

448
00:17:36,320 --> 00:17:37,520
你没有做任何更新

449
00:17:37,560 --> 00:17:40,440
那这里面所以说你的工作clean等等

450
00:17:40,480 --> 00:17:43,120
你还有其它一些命令 git Pull

451
00:17:43,160 --> 00:17:45,160
下载新代码 git push

452
00:17:45,200 --> 00:17:47,840
推你的代码到git池里面去等等

453
00:17:47,880 --> 00:17:49,560
这都是一些常见的命令

454
00:17:49,600 --> 00:17:51,280
如果大家需要了解的话

455
00:17:51,320 --> 00:17:53,400
结合我们的文档中给出的链接

456
00:17:53,440 --> 00:17:55,520
可以去进一步学习一下

457
00:17:55,560 --> 00:17:58,040
那大致的一个调试和整个过程呢

458
00:17:58,080 --> 00:17:59,320
就给大家介绍到这儿

459
00:17:59,360 --> 00:18:02,760
我想还有很多一些细节呢

460
00:18:02,800 --> 00:18:04,600
特别是gdb一些使用呢

461
00:18:04,640 --> 00:18:05,520
其实也有必要

462
00:18:05,560 --> 00:18:08,280
大家去看看它怎么来调试的

463
00:18:08,320 --> 00:18:09,760
你可以用小的应用程序来调试

464
00:18:09,800 --> 00:18:11,320
也可以用刚才说的那个工具

465
00:18:11,360 --> 00:18:13,880
比如说命令行方式也可以调试

466
00:18:13,920 --> 00:18:16,120
我们刚才展示了eclipse方式来调试

467
00:18:16,160 --> 00:18:18,160
比如make debug

468
00:18:18,200 --> 00:18:20,280
那你可以看着我起了qemu一样的

469
00:18:20,320 --> 00:18:24,960
然后它起了一个字符方式的cgdb

470
00:18:25,000 --> 00:18:28,560
那其实一样它也断到了这一点 next

471
00:18:28,600 --> 00:18:29,880
可以看到它走到哪去了

472
00:18:29,920 --> 00:18:36,280
走到了88行 86行 88行到91行等等 p.ph

473
00:18:36,320 --> 00:18:37,320
打出来这个值

474
00:18:37,360 --> 00:18:38,440
如果执行完91行的话 

475
00:18:38,480 --> 00:18:40,920
发现它结果是不一样的

476
00:18:40,960 --> 00:18:42,360
刚才我们在那儿实验是一样的

477
00:18:42,400 --> 00:18:45,600
就是你可以选择你不同方式来调试

478
00:18:45,640 --> 00:18:48,400
如果continue 那你可以看着

479
00:18:48,440 --> 00:18:52,840
刚才我们把这个设置成always on top的话

480
00:18:52,880 --> 00:18:54,960
那么我们continue可以看到

481
00:18:55,000 --> 00:18:56,840
它的一个变化过程也很类似

482
00:18:56,880 --> 00:18:58,400
然后ctrl c中断一下

483
00:18:58,440 --> 00:19:01,040
它执行到了一个我们看不到的地方

484
00:19:01,080 --> 00:19:03,360
是100073对应不到源代码

485
00:19:03,400 --> 00:19:06,880
所以是两个问号 这是用gdb来调试一个简单

486
00:19:06,920 --> 00:19:09,880
做退出 quit退出 把这个要关掉

487
00:19:09,920 --> 00:19:12,440
我们可以看着了就是通过不同的方式

488
00:19:12,480 --> 00:19:15,280
有图形方式 有字符方式

489
00:19:15,320 --> 00:19:21,600
都可以用来编辑分析和运行调试

490
00:19:21,640 --> 00:19:23,560
我们的操作系统的实验

491
00:19:23,600 --> 00:19:24,600
这里面还有很多工具

492
00:19:24,640 --> 00:19:26,280
可以值得大家去探索和摸索

493
00:19:26,320 --> 00:19:30,200
关于工具的介绍大致就讲到这里

494
00:19:30,240 --> 00:19:31,120
谢谢大家

495
00:19:31,160 --> 00:19:32,640


496
00:19:32,680 --> 00:19:33,240


497
00:19:33,280 --> 00:19:33,280


